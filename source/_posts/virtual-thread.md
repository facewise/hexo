---
title: 가상 스레드 (Virtual Thread)
date: 2024-01-29 17:23:07
category: Java
---

# 가상 스레드 도입 배경

이전부터 [Project Loom](https://wiki.openjdk.org/display/loom/Main)에 대해서 관심이 많았다.

지금까지 자바 서버는 요청 트래픽이 몰리는 상황에서 값비싼 컨텍스트 스위치 비용을 지불해왔다.
<br>
**이를 해결하기 위해 다양한 시도를 해왔다.**

- Reactive Streams와 같은 비동기 API
- 코루틴을 자바에 추가하기

Spring WebFlux는 Reactive API를 훌륭하게 구현해서 스레드가 부족한 환경에서 성능을 개선했다.

또, JVM 진영의 코틀린에서 coroutine을 통해 메소드를 비동기적으로 호출할 수 있게 지원해줬다.
<br>
**하지만 위의 시도들은 다음과 같은 이유로 자바의 표준이 되지 못했다**

- 웹플럭스는 요청을 처리하는 순서가 보장되지 않아 디버깅을 단계별로 진행할 수 없고, 처리되는 스레드가 다를 수 있어 stack trace도 제공할 수 없었다.
<br>
- 자바 플랫폼에 코루틴 API를 적용하려면 엄청난 대규모 작업이 될 수 밖에 없다. 기존의 스레드 API를 사용해 개발했던 내용은 모두 걷어내야 한다.
<br>

코루틴을 사용하려면 코틀린을 사용하면 되지만, 여전히 자바를 사용하고 싶은 사람은 코루틴도 해결책이 아니었다.

이 때문에 **Project Loom**은 자바 방식으로 해결하기 위해 3가지 기능을 도입하기로 하는데 그 중 첫 번째가 [가상 스레드(Virtual Thread)](https://openjdk.org/jeps/425)이다.

<br>

# 가상 스레드란?

가상 스레드는 한마디로 JVM에 의해 관리되는 경량 스레드이다.

기존의 JVM 스레드는 플랫폼 스레드(Platform Thread)라고 부르며 이는 OS 스레드를 래핑(Wrapping)한 스레드여서 OS 스레드와 일대일 관계였다.
<br>

**플랫폼 스레드는 다음과 같은 단점이 있다.**
- OS 스레드의 래퍼로 구현하기 때문에 사용가능한 스레드 수가 제한됨
- OS에 의해 생성되고 스케줄링되기 때문에 비용이 비싸고 컨텍스트 스위칭 비용도 비싸다
<br>

이에 비해 가상 스레드는 JDK에서 구현하고 제공하는 user-mode 스레드이다.

가상 스레드는 특정 OS 스레드에 연결되어 있지 않고 M:N 스케줄링을 사용한다. 가상 스레드의 수(M)가 더 적은 수(N)의 OS 스레드에서 실행되게 예약한다.

